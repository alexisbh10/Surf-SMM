{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;\n\nconst events_1 = require(\"events\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst os_1 = require(\"os\");\n\nconst path_1 = require(\"path\");\n\nconst stream_1 = require(\"stream\");\n\nconst fs_1 = require(\"fs\");\n\nconst util_1 = require(\"util\");\n\nfunction toArray(source) {\n  if (typeof source === 'undefined' || source === null) {\n    return [];\n  } else if (!Array.isArray(source)) {\n    return [source];\n  }\n\n  return source;\n}\n/**\r\n * adds arguments as properties to obj\r\n */\n\n\nfunction extend(obj, ...args) {\n  Array.prototype.slice.call(arguments, 1).forEach(function (source) {\n    if (source) {\n      for (let key in source) {\n        obj[key] = source[key];\n      }\n    }\n  });\n  return obj;\n}\n/**\r\n * gets a random int from 0-10000000000\r\n */\n\n\nfunction getRandomInt() {\n  return Math.floor(Math.random() * 10000000000);\n}\n\nconst execPromise = (0, util_1.promisify)(child_process_1.exec);\n\nclass PythonShellError extends Error {}\n\nexports.PythonShellError = PythonShellError;\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */\n\nclass NewlineTransformer extends stream_1.Transform {\n  _transform(chunk, encoding, callback) {\n    let data = chunk.toString();\n    if (this._lastLineData) data = this._lastLineData + data;\n    const lines = data.split(os_1.EOL);\n    this._lastLineData = lines.pop(); //@ts-ignore this works, node ignores the encoding if it's a number\n\n    lines.forEach(this.push.bind(this));\n    callback();\n  }\n\n  _flush(done) {\n    if (this._lastLineData) this.push(this._lastLineData);\n    this._lastLineData = null;\n    done();\n  }\n\n}\n\nexports.NewlineTransformer = NewlineTransformer;\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */\n\nclass PythonShell extends events_1.EventEmitter {\n  /**\r\n   * spawns a python process\r\n   * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n   * @param options\r\n   * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n   * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n   */\n  constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {\n    super();\n    /**\r\n     * returns either pythonshell func (if val string) or custom func (if val Function)\r\n     */\n\n    function resolve(type, val) {\n      if (typeof val === 'string') {\n        // use a built-in function using its name\n        return PythonShell[type][val];\n      } else if (typeof val === 'function') {\n        // use a custom function\n        return val;\n      }\n    }\n\n    if (scriptPath.trim().length == 0) throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\n    let self = this;\n    let errorData = '';\n    events_1.EventEmitter.call(this);\n    options = extend({}, PythonShell.defaultOptions, options);\n    let pythonPath;\n\n    if (!options.pythonPath) {\n      pythonPath = PythonShell.defaultPythonPath;\n    } else pythonPath = options.pythonPath;\n\n    let pythonOptions = toArray(options.pythonOptions);\n    let scriptArgs = toArray(options.args);\n    this.scriptPath = (0, path_1.join)(options.scriptPath || '', scriptPath);\n    this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\n    this.mode = options.mode || 'text';\n    this.formatter = resolve('format', options.formatter || this.mode);\n    this.parser = resolve('parse', options.parser || this.mode); // We don't expect users to ever format stderr as JSON so we default to text mode\n\n    this.stderrParser = resolve('parse', options.stderrParser || 'text');\n    this.terminated = false;\n    this.childProcess = (0, child_process_1.spawn)(pythonPath, this.command, options);\n    ['stdout', 'stdin', 'stderr'].forEach(function (name) {\n      self[name] = self.childProcess[name];\n      self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\n    }); // Node buffers stdout&stderr in batches regardless of newline placement\n    // This is troublesome if you want to recieve distinct individual messages\n    // for example JSON parsing breaks if it recieves partial JSON\n    // so we use newlineTransformer to emit each batch seperated by newline\n\n    if (this.parser && this.stdout) {\n      if (!stdoutSplitter) stdoutSplitter = new NewlineTransformer(); // note that setting the encoding turns the chunk into a string\n\n      stdoutSplitter.setEncoding(options.encoding || 'utf8');\n      this.stdout.pipe(stdoutSplitter).on('data', chunk => {\n        this.emit('message', self.parser(chunk));\n      });\n    } // listen to stderr and emit errors for incoming data\n\n\n    if (this.stderrParser && this.stderr) {\n      if (!stderrSplitter) stderrSplitter = new NewlineTransformer(); // note that setting the encoding turns the chunk into a string\n\n      stderrSplitter.setEncoding(options.encoding || 'utf8');\n      this.stderr.pipe(stderrSplitter).on('data', chunk => {\n        this.emit('stderr', self.stderrParser(chunk));\n      });\n    }\n\n    if (this.stderr) {\n      this.stderr.on('data', function (data) {\n        errorData += '' + data;\n      });\n      this.stderr.on('end', function () {\n        self.stderrHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stderrHasEnded = true;\n    }\n\n    if (this.stdout) {\n      this.stdout.on('end', function () {\n        self.stdoutHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stdoutHasEnded = true;\n    }\n\n    this.childProcess.on('error', function (err) {\n      self.emit('error', err);\n    });\n    this.childProcess.on('exit', function (code, signal) {\n      self.exitCode = code;\n      self.exitSignal = signal;\n      terminateIfNeeded();\n    });\n\n    function terminateIfNeeded() {\n      if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null) return;\n      let err;\n\n      if (self.exitCode && self.exitCode !== 0) {\n        if (errorData) {\n          err = self.parseError(errorData);\n        } else {\n          err = new PythonShellError('process exited with code ' + self.exitCode);\n        }\n\n        err = extend(err, {\n          executable: pythonPath,\n          options: pythonOptions.length ? pythonOptions : null,\n          script: self.scriptPath,\n          args: scriptArgs.length ? scriptArgs : null,\n          exitCode: self.exitCode\n        }); // do not emit error if only a callback is used\n\n        if (self.listeners('pythonError').length || !self._endCallback) {\n          self.emit('pythonError', err);\n        }\n      }\n\n      self.terminated = true;\n      self.emit('close');\n      self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\n    }\n\n    ;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @returns rejects promise w/ string error output if syntax failure\r\n   */\n\n\n  static checkSyntax(code) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const randomInt = getRandomInt();\n      const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;\n      const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);\n      return writeFilePromise(filePath, code).then(() => {\n        return this.checkSyntaxFile(filePath);\n      });\n    });\n  }\n\n  static getPythonPath() {\n    return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @returns {Promise} rejects w/ stderr if syntax failure\r\n   */\n\n\n  static checkSyntaxFile(filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const pythonPath = this.getPythonPath();\n      let compileCommand = `${pythonPath} -m py_compile ${filePath}`;\n      return execPromise(compileCommand);\n    });\n  }\n  /**\r\n   * Runs a Python script and returns collected messages\r\n   * @param  {string}   scriptPath   The path to the script to execute\r\n   * @param  {Options}   options  The execution options\r\n   * @param  {Function} callback The callback function to invoke with the script results\r\n   * @return {PythonShell}       The PythonShell instance\r\n   */\n\n\n  static run(scriptPath, options, callback) {\n    let pyshell = new PythonShell(scriptPath, options);\n    let output = [];\n    return pyshell.on('message', function (message) {\n      output.push(message);\n    }).end(function (err) {\n      return callback(err ? err : null, output.length ? output : null);\n    });\n  }\n\n  /**\r\n   * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n   * @param  {string}   code   The python code to execute\r\n   * @param  {Options}   options  The execution options\r\n   * @param  {Function} callback The callback function to invoke with the script results\r\n   * @return {PythonShell}       The PythonShell instance\r\n   */\n  static runString(code, options, callback) {\n    // put code in temp file\n    const randomInt = getRandomInt();\n    const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;\n    (0, fs_1.writeFileSync)(filePath, code);\n    return PythonShell.run(filePath, options, callback);\n  }\n\n  static getVersion(pythonPath) {\n    if (!pythonPath) pythonPath = this.getPythonPath();\n    return execPromise(pythonPath + \" --version\");\n  }\n\n  static getVersionSync(pythonPath) {\n    if (!pythonPath) pythonPath = this.getPythonPath();\n    return (0, child_process_1.execSync)(pythonPath + \" --version\").toString();\n  }\n  /**\r\n   * Parses an error thrown from the Python process through stderr\r\n   * @param  {string|Buffer} data The stderr contents to parse\r\n   * @return {Error} The parsed error with extended stack trace when traceback is available\r\n   */\n\n\n  parseError(data) {\n    let text = '' + data;\n    let error;\n\n    if (/^Traceback/.test(text)) {\n      // traceback data is available\n      let lines = text.trim().split(os_1.EOL);\n      let exception = lines.pop();\n      error = new PythonShellError(exception);\n      error.traceback = data; // extend stack trace\n\n      error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\n      error.stack += lines.slice(1).join(os_1.EOL + '  ');\n    } else {\n      // otherwise, create a simpler error with stderr contents\n      error = new PythonShellError(text);\n    }\n\n    return error;\n  }\n\n  /**\r\n   * Sends a message to the Python shell through stdin\r\n   * Override this method to format data to be sent to the Python process\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  send(message) {\n    if (!this.stdin) throw new Error(\"stdin not open for writing\");\n    let data = this.formatter ? this.formatter(message) : message;\n    if (this.mode !== 'binary') data += os_1.EOL;\n    this.stdin.write(data);\n    return this;\n  }\n\n  /**\r\n   * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n   * this should cause the process to finish its work and close.\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  end(callback) {\n    if (this.childProcess.stdin) {\n      this.childProcess.stdin.end();\n    }\n\n    this._endCallback = callback;\n    return this;\n  }\n\n  /**\r\n   * Sends a kill signal to the process\r\n   * @returns {PythonShell} The same instance for chaining calls\r\n   */\n  kill(signal) {\n    this.terminated = this.childProcess.kill(signal);\n    return this;\n  }\n\n  /**\r\n   * Alias for kill.\r\n   * @deprecated\r\n   */\n  terminate(signal) {\n    // todo: remove this next breaking release\n    return this.kill(signal);\n  }\n\n}\n\nexports.PythonShell = PythonShell; // starting 2020 python2 is deprecated so we choose 3 as default\n\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\nPythonShell.defaultOptions = {}; //allow global overrides for options\n// built-in formatters\n\nPythonShell.format = {\n  text: function toText(data) {\n    if (!data) return '';else if (typeof data !== 'string') return data.toString();\n    return data;\n  },\n  json: function toJson(data) {\n    return JSON.stringify(data);\n  }\n}; //built-in parsers\n\nPythonShell.parse = {\n  text: function asText(data) {\n    return data;\n  },\n  json: function asJson(data) {\n    return JSON.parse(data);\n  }\n};\n;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","PythonShell","NewlineTransformer","PythonShellError","events_1","require","child_process_1","os_1","path_1","stream_1","fs_1","util_1","toArray","source","Array","isArray","extend","obj","args","prototype","slice","call","arguments","forEach","key","getRandomInt","Math","floor","random","execPromise","promisify","exec","Error","Transform","_transform","chunk","encoding","callback","data","toString","_lastLineData","lines","split","EOL","pop","push","bind","_flush","EventEmitter","constructor","scriptPath","options","stdoutSplitter","stderrSplitter","type","val","trim","length","self","errorData","defaultOptions","pythonPath","defaultPythonPath","pythonOptions","scriptArgs","join","command","concat","mode","formatter","parser","stderrParser","terminated","childProcess","spawn","name","setEncoding","stdout","pipe","on","emit","stderr","stderrHasEnded","terminateIfNeeded","stdoutHasEnded","err","code","signal","exitCode","exitSignal","parseError","executable","script","listeners","_endCallback","checkSyntax","randomInt","filePath","tmpdir","sep","writeFilePromise","writeFile","checkSyntaxFile","getPythonPath","compileCommand","run","pyshell","output","message","end","runString","writeFileSync","getVersion","getVersionSync","execSync","text","error","test","exception","traceback","stack","send","stdin","write","kill","terminate","process","platform","format","toText","json","toJson","JSON","stringify","parse","asText","asJson"],"sources":["/home/dar/Escritorio/SMM/Surf-SMM/frontend/node_modules/python-shell/index.js"],"sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;\r\nconst events_1 = require(\"events\");\r\nconst child_process_1 = require(\"child_process\");\r\nconst os_1 = require(\"os\");\r\nconst path_1 = require(\"path\");\r\nconst stream_1 = require(\"stream\");\r\nconst fs_1 = require(\"fs\");\r\nconst util_1 = require(\"util\");\r\nfunction toArray(source) {\r\n    if (typeof source === 'undefined' || source === null) {\r\n        return [];\r\n    }\r\n    else if (!Array.isArray(source)) {\r\n        return [source];\r\n    }\r\n    return source;\r\n}\r\n/**\r\n * adds arguments as properties to obj\r\n */\r\nfunction extend(obj, ...args) {\r\n    Array.prototype.slice.call(arguments, 1).forEach(function (source) {\r\n        if (source) {\r\n            for (let key in source) {\r\n                obj[key] = source[key];\r\n            }\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * gets a random int from 0-10000000000\r\n */\r\nfunction getRandomInt() {\r\n    return Math.floor(Math.random() * 10000000000);\r\n}\r\nconst execPromise = (0, util_1.promisify)(child_process_1.exec);\r\nclass PythonShellError extends Error {\r\n}\r\nexports.PythonShellError = PythonShellError;\r\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */\r\nclass NewlineTransformer extends stream_1.Transform {\r\n    _transform(chunk, encoding, callback) {\r\n        let data = chunk.toString();\r\n        if (this._lastLineData)\r\n            data = this._lastLineData + data;\r\n        const lines = data.split(os_1.EOL);\r\n        this._lastLineData = lines.pop();\r\n        //@ts-ignore this works, node ignores the encoding if it's a number\r\n        lines.forEach(this.push.bind(this));\r\n        callback();\r\n    }\r\n    _flush(done) {\r\n        if (this._lastLineData)\r\n            this.push(this._lastLineData);\r\n        this._lastLineData = null;\r\n        done();\r\n    }\r\n}\r\nexports.NewlineTransformer = NewlineTransformer;\r\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */\r\nclass PythonShell extends events_1.EventEmitter {\r\n    /**\r\n     * spawns a python process\r\n     * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n     * @param options\r\n     * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n     * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n     */\r\n    constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {\r\n        super();\r\n        /**\r\n         * returns either pythonshell func (if val string) or custom func (if val Function)\r\n         */\r\n        function resolve(type, val) {\r\n            if (typeof val === 'string') {\r\n                // use a built-in function using its name\r\n                return PythonShell[type][val];\r\n            }\r\n            else if (typeof val === 'function') {\r\n                // use a custom function\r\n                return val;\r\n            }\r\n        }\r\n        if (scriptPath.trim().length == 0)\r\n            throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\r\n        let self = this;\r\n        let errorData = '';\r\n        events_1.EventEmitter.call(this);\r\n        options = extend({}, PythonShell.defaultOptions, options);\r\n        let pythonPath;\r\n        if (!options.pythonPath) {\r\n            pythonPath = PythonShell.defaultPythonPath;\r\n        }\r\n        else\r\n            pythonPath = options.pythonPath;\r\n        let pythonOptions = toArray(options.pythonOptions);\r\n        let scriptArgs = toArray(options.args);\r\n        this.scriptPath = (0, path_1.join)(options.scriptPath || '', scriptPath);\r\n        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\r\n        this.mode = options.mode || 'text';\r\n        this.formatter = resolve('format', options.formatter || this.mode);\r\n        this.parser = resolve('parse', options.parser || this.mode);\r\n        // We don't expect users to ever format stderr as JSON so we default to text mode\r\n        this.stderrParser = resolve('parse', options.stderrParser || 'text');\r\n        this.terminated = false;\r\n        this.childProcess = (0, child_process_1.spawn)(pythonPath, this.command, options);\r\n        ['stdout', 'stdin', 'stderr'].forEach(function (name) {\r\n            self[name] = self.childProcess[name];\r\n            self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\r\n        });\r\n        // Node buffers stdout&stderr in batches regardless of newline placement\r\n        // This is troublesome if you want to recieve distinct individual messages\r\n        // for example JSON parsing breaks if it recieves partial JSON\r\n        // so we use newlineTransformer to emit each batch seperated by newline\r\n        if (this.parser && this.stdout) {\r\n            if (!stdoutSplitter)\r\n                stdoutSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stdoutSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stdout.pipe(stdoutSplitter).on('data', (chunk) => {\r\n                this.emit('message', self.parser(chunk));\r\n            });\r\n        }\r\n        // listen to stderr and emit errors for incoming data\r\n        if (this.stderrParser && this.stderr) {\r\n            if (!stderrSplitter)\r\n                stderrSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stderrSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stderr.pipe(stderrSplitter).on('data', (chunk) => {\r\n                this.emit('stderr', self.stderrParser(chunk));\r\n            });\r\n        }\r\n        if (this.stderr) {\r\n            this.stderr.on('data', function (data) {\r\n                errorData += '' + data;\r\n            });\r\n            this.stderr.on('end', function () {\r\n                self.stderrHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stderrHasEnded = true;\r\n        }\r\n        if (this.stdout) {\r\n            this.stdout.on('end', function () {\r\n                self.stdoutHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stdoutHasEnded = true;\r\n        }\r\n        this.childProcess.on('error', function (err) {\r\n            self.emit('error', err);\r\n        });\r\n        this.childProcess.on('exit', function (code, signal) {\r\n            self.exitCode = code;\r\n            self.exitSignal = signal;\r\n            terminateIfNeeded();\r\n        });\r\n        function terminateIfNeeded() {\r\n            if (!self.stderrHasEnded || !self.stdoutHasEnded || (self.exitCode == null && self.exitSignal == null))\r\n                return;\r\n            let err;\r\n            if (self.exitCode && self.exitCode !== 0) {\r\n                if (errorData) {\r\n                    err = self.parseError(errorData);\r\n                }\r\n                else {\r\n                    err = new PythonShellError('process exited with code ' + self.exitCode);\r\n                }\r\n                err = extend(err, {\r\n                    executable: pythonPath,\r\n                    options: pythonOptions.length ? pythonOptions : null,\r\n                    script: self.scriptPath,\r\n                    args: scriptArgs.length ? scriptArgs : null,\r\n                    exitCode: self.exitCode\r\n                });\r\n                // do not emit error if only a callback is used\r\n                if (self.listeners('pythonError').length || !self._endCallback) {\r\n                    self.emit('pythonError', err);\r\n                }\r\n            }\r\n            self.terminated = true;\r\n            self.emit('close');\r\n            self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\r\n        }\r\n        ;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns rejects promise w/ string error output if syntax failure\r\n     */\r\n    static checkSyntax(code) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const randomInt = getRandomInt();\r\n            const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;\r\n            const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);\r\n            return writeFilePromise(filePath, code).then(() => {\r\n                return this.checkSyntaxFile(filePath);\r\n            });\r\n        });\r\n    }\r\n    static getPythonPath() {\r\n        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns {Promise} rejects w/ stderr if syntax failure\r\n     */\r\n    static checkSyntaxFile(filePath) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const pythonPath = this.getPythonPath();\r\n            let compileCommand = `${pythonPath} -m py_compile ${filePath}`;\r\n            return execPromise(compileCommand);\r\n        });\r\n    }\r\n    /**\r\n     * Runs a Python script and returns collected messages\r\n     * @param  {string}   scriptPath   The path to the script to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\r\n    static run(scriptPath, options, callback) {\r\n        let pyshell = new PythonShell(scriptPath, options);\r\n        let output = [];\r\n        return pyshell.on('message', function (message) {\r\n            output.push(message);\r\n        }).end(function (err) {\r\n            return callback(err ? err : null, output.length ? output : null);\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n     * @param  {string}   code   The python code to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\r\n    static runString(code, options, callback) {\r\n        // put code in temp file\r\n        const randomInt = getRandomInt();\r\n        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;\r\n        (0, fs_1.writeFileSync)(filePath, code);\r\n        return PythonShell.run(filePath, options, callback);\r\n    }\r\n    ;\r\n    static getVersion(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return execPromise(pythonPath + \" --version\");\r\n    }\r\n    static getVersionSync(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return (0, child_process_1.execSync)(pythonPath + \" --version\").toString();\r\n    }\r\n    /**\r\n     * Parses an error thrown from the Python process through stderr\r\n     * @param  {string|Buffer} data The stderr contents to parse\r\n     * @return {Error} The parsed error with extended stack trace when traceback is available\r\n     */\r\n    parseError(data) {\r\n        let text = '' + data;\r\n        let error;\r\n        if (/^Traceback/.test(text)) {\r\n            // traceback data is available\r\n            let lines = text.trim().split(os_1.EOL);\r\n            let exception = lines.pop();\r\n            error = new PythonShellError(exception);\r\n            error.traceback = data;\r\n            // extend stack trace\r\n            error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\r\n            error.stack += lines.slice(1).join(os_1.EOL + '  ');\r\n        }\r\n        else {\r\n            // otherwise, create a simpler error with stderr contents\r\n            error = new PythonShellError(text);\r\n        }\r\n        return error;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a message to the Python shell through stdin\r\n     * Override this method to format data to be sent to the Python process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    send(message) {\r\n        if (!this.stdin)\r\n            throw new Error(\"stdin not open for writing\");\r\n        let data = this.formatter ? this.formatter(message) : message;\r\n        if (this.mode !== 'binary')\r\n            data += os_1.EOL;\r\n        this.stdin.write(data);\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n     * this should cause the process to finish its work and close.\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    end(callback) {\r\n        if (this.childProcess.stdin) {\r\n            this.childProcess.stdin.end();\r\n        }\r\n        this._endCallback = callback;\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a kill signal to the process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    kill(signal) {\r\n        this.terminated = this.childProcess.kill(signal);\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Alias for kill.\r\n     * @deprecated\r\n     */\r\n    terminate(signal) {\r\n        // todo: remove this next breaking release\r\n        return this.kill(signal);\r\n    }\r\n}\r\nexports.PythonShell = PythonShell;\r\n// starting 2020 python2 is deprecated so we choose 3 as default\r\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\r\nPythonShell.defaultOptions = {}; //allow global overrides for options\r\n// built-in formatters\r\nPythonShell.format = {\r\n    text: function toText(data) {\r\n        if (!data)\r\n            return '';\r\n        else if (typeof data !== 'string')\r\n            return data.toString();\r\n        return data;\r\n    },\r\n    json: function toJson(data) {\r\n        return JSON.stringify(data);\r\n    }\r\n};\r\n//built-in parsers\r\nPythonShell.parse = {\r\n    text: function asText(data) {\r\n        return data;\r\n    },\r\n    json: function asJson(data) {\r\n        return JSON.parse(data);\r\n    }\r\n};\r\n;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}